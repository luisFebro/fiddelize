/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

// import { clientsClaim } from "workbox-core";
// import { ExpirationPlugin } from "workbox-expiration";
// import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
// import { registerRoute } from "workbox-routing";
// import { StaleWhileRevalidate } from "workbox-strategies";

// clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
// precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
// const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
// registerRoute(
//     // Return false to exempt requests from being fulfilled by index.html.
//     ({ request, url }) => {
//         // If this isn't a navigation, skip.
//         if (request.mode !== "navigate") {
//             return false;
//         } // If this is a URL that starts with /_, skip.

//         if (url.pathname.startsWith("/_")) {
//             return false;
//         } // If this looks like a URL for a resource, because it contains // a file extension, skip.

//         if (url.pathname.match(fileExtensionRegexp)) {
//             return false;
//         } // Return true to signal that we want to use the handler.

//         return true;
//     },
//     createHandlerBoundToURL(`${process.env.PUBLIC_URL}/index.html`)
// );

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
// registerRoute(
//     // Add in any other file extensions or routing criteria as needed.
//     ({ url }) =>
//         url.origin === self.location.origin && url.pathname.endsWith(".png"), // Customize this strategy as needed, e.g., by changing to CacheFirst.
//     new StaleWhileRevalidate({
//         cacheName: "images",
//         plugins: [
//             // Ensure that once this runtime cache reaches a maximum size the
//             // least-recently used images are removed.
//             new ExpirationPlugin({ maxEntries: 50 }),
//         ],
//     })
// );

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
    if (event.data && event.data.type === "SKIP_WAITING") {
        self.skipWaiting();
    }
});

// Any other custom service worker logic can go here.

/*
The common practice for a notification click is for it to close and perform some other logic (i.e. open a window or make some API call to the application)
https://developers.google.com/web/fundamentals/push-notifications/notification-behaviour
https://stackoverflow.com/questions/48547295/pwa-service-worker-notification-click
*/
self.addEventListener("notificationclick", (event) => {
    console.log("event", event);
    const clickedNotification = event.notification;
    const clickedActionBtn = event.action; // it is an empty string if not clicked
    const extraOptions = clickedNotification.data || {};

    if (extraOptions.close) event.notification.close();

    const isNormalNotifClick = !clickedActionBtn;
    if (isNormalNotifClick) {
        console.log("Normal Notification Click.");
        return;
    }

    switch (clickedActionBtn) {
        case "openApp":
            // Note that you don't have window access in service-worker. To navigate to the URL, you'd need to use clients.openWindow instead.
            const promise = clients.openWindow(extraOptions.url_openApp);
            event.waitUntil(promise);
            break;
        default:
            console.log(`Unknown action clicked: '${event.action}'`);
            break;
    }

    // Do something as the result of the notification click
    // const promiseChain = doSomething();
    // event.waitUntil(promiseChain); // n1 You still need to make use of event.waitUntil() to keep the service worker running while your code is busy. - So, the waitUntil method is used to tell the browser not to terminate the service worker until the promise passed to waitUntil is either resolved or rejected.
});

/*
There is also a notificationclose event that is called if the user dismisses one of your notifications (i.e. rather than clicking the notification, the user clicks the cross or swipes the notification away).
This event is normally used for analytics to track user engagement with notifications.
 */
self.addEventListener("notificationclose", (event) => {
    const dismissedNotification = event.notification;
    console.log("dismissedNotification", dismissedNotification);
    console.log("user dismissed the notification");
    // const promiseChain = notificationCloseAnalytics();
    // event.waitUntil(promiseChain);
});

/* COMMENTS
n1: waitUntil
One of the things to understand about service workers is that you have little control over when the service worker code is going to run. The browser decides when to wake it up and when to terminate it. The only way you can tell the browser, "Hey, I'm super busy doing important stuff", is to pass a promise into the event.waitUntil() method. With this, the browser will keep the service worker running until the promise you passed in has settled.
*/

/* OLD TRAVERSY SOLUTION
self.addEventListener('push', event => { //n1
    const data = event.data.json();
    const options = {
        body: data.body,
        icon: "http://image.ibb.co/frYOFd/tmlogo.png",
        requireInteraction: true,
    }

    event.waitUntil(
        self.registration.showNotification(data.title, options)
    );
})


COMMENTS
n1: traversy version:
console.log("Service Worker Loaded...");

self.addEventListener("push", e => {
  const data = e.data.json();
  console.log("Push Recieved...");
  self.registration.showNotification(data.title, {
    body: "Notified by Traversy Media!",
    icon: "http://image.ibb.co/frYOFd/tmlogo.png"
  });
});

*/
